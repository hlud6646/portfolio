{% extends "/blog/layout.html" %}
{% set active_page = "5-11-2019" %}

{% block title %}
5-11-2019
{% endblock %}

{% block header %}
	<pre>
		<code class="language-bash">
	ubuntu@ip-123-45-6-789:~$ sudo apt-get -y install nginx python3 flask gunicorn 
		</code>
	</pre>
{% endblock %}

{% block subtitle %}
	Building an Ubuntu Server.
{% endblock %}

{% block words %}	
It might seem strange that a beginner would want to add their version to an already crowded pack 
of server config blog posts, but having been through many of the walk-throughs that are already
out there, I figure there is a place for one which moves more slowly and 
does more checks along the way.
<br><br>
In broad strokes, we are building a server on an AWS Lightsail machine, with incoming requests 
going to Nginx. From there they are passed to a flask app which is running on localhost.  
The flask server is only intended for development, so the app is written in flask but then 
run though a production server, namely Gunicorn.
The gunicorn process is wrapped in a supervisor job, which really is just a safegaurd that 
reboots the server if it crashes for some reason.
Clearly this is hugely over-engineered for a hello world app but for me it was helpful to get a
minimal project working in the full framework before adding the rest of the functionality.



<ol>
	<li>
		<h4>Lauch Nginx on a Lightsail Instance.</h4>
		Navigate to the AWS Lightsail page and create an OS-only ubuntu instance in your region.
		You can see in the 'Networking' tab of the instance that these come with ports 80 and 22
		open already, so you don't need to worry about changing firewall settings.
		Connect to your instance, then check for any updates and install Nginx.
		<pre><code class="language-bash">~$ sudo apt-get -y update
~$ sudo apt-get -y install nginx</code></pre>
	</li>

	<li>
		<h4>Check that Nginx is up.</h4>
		Nginx should start automatically after installation.  You can check with the command 
		<code class="bash">$ service nginx status</code> or better still navigate to server's public IP
		where you should see nginx's welcome page:
		<img src="../static/images/blog/5-11-2019/nginx.png" alt=":(">
	</li>

	<li>
		<h4>Attach a Static IP.</h4>
		Back in the Lightsail console, attach a static IP to the instance.  Connect to the instance
		using this new IP, and confirm that you get the same welcome page from nginx if you enter
		it in the browser.
	</li>

	<li>
		<h4>Installing Python, Venv and Flask.</li></h4>
		First create a directory for the project and move into it with 
		<code class="language-python">mkdir hello && cd hello.</code>
		We need Python3, the virtual environent package and the Flask web framework.
		The following first command installs python and venv.
		The second creates a new virtual environment in a hidden directory called 
		<code class="language-bash">.venv</code> then activates (launches) a shell inside it.
		From within the environment pip upgrades itself and then installs flask.
		I'll use the dollar sign $ for commands in the instance's regular shell 
		and the pound sterling £ for commands in the virtual environment.
		<pre><code class="language-bash">~/hello$ sudo apt-get -y install python3 python3-venv
~/hello$ python3 -m venv .venv && source .venv/bin/activate
~/hello£ pip install --upgrade pip && pip install flask</code></pre>

	<li>
		<h4>Fire up a Hello World server.</h4>
		Drop a minimal application called 
		<code class="language-bash">myapp.py</code> in the 
		<code class="language-bash">~/hello</code> directory. One like this would work:
		<pre><code class="language-python">#~/hello/myapp.py
from flask import Flask, Response
app = Flask(__name__)

@app.route('/')
def hi():
	return Response("Oh, Hi Mark.")</code></pre>
	</li>

	Set it to go and fire it up.  I prefer to have localhost servers on 8000 from the
	get go, but flask will default to 5000 if you don't tell it anything.
	<pre><code class="language-bash">~/hello£ export FLASK_APP=myapp
~/hello£ export FLASK_ENV=development
~/hello£ export FLASK_RUN_PORT=8000
~/hello£ flask run</code></pre>

		Since the Lightsail instance is headless we can't check that this is working 
		in the broswer like you normally would. Open another shell in the remote 
		machine (since the first one is now stuck running flask in the foreground) and 
		check that the server is alive with something like 
		<code class="language-bash">curl localhost:8000</code>.
		The server window should acknowledge the request and the other one should print 
		<a href="https://youtu.be/aekfPU0SwNw?t=5"> <font color="black">"Oh, Hi Mark.</font></a>


	<li>
		<h4>Setup Nginx as Reverse Proxy.</h4>
		Here we configure nginx to forward any incoming requests on port 80 to our flask 
		server.
		By default nginx configuration files live in 
		<code class="language-bash">/etc/nginx</code>.  We need to get rid of the 
		default configuration (that gives us the 'Welcome to Nginx' page) and put in our own.
		Delete the file 
		<code class="language-bash">/etc/nginx/sites-enabled/default</code> or hide it somewhere.  
		I created a directory
		<code class="language-bash">/etc/nginx/sites-diabled</code> and moved it there. 
		All of this needs to be done as sudo since /etc is protected.
		<br><br>
		Put the following in a file called
		<code class="language-bash">/etc/nginx/sites-enabled/hello</code>

		<pre><code class="language-nginx">server {
  listen 80;
  listen [::]:80;

  server_name _;

  location / {
      proxy_pass http://localhost:8000/;
  }
}</code></pre>
	
		Now that the configuration has changed we need to restart nginx with 
		<code class="language-bash">~$ sudo service nginx restart</code>.
		If you open the static IP in your browser you should get the "Oh Hi Mark" message 
		and the flask activity log in the should also tell you a request was made
		just like when you used curl to test it before.  
		</li>

	<li>
		<h4>Moving to Gunicorn.</h4>
		As mentioned earlier, the flask server is only for development so we'll move it
		to Gunicorn.  First kill the flask server to free port 8000. 
		In the virtual environment install gunicorn and start it up:
		<pre><code class="language-bash">~/hello£ pip install gunicorn
~/hello£ gunicorn --bind localhost:8000 myapp:app</code></pre>
		The 'bind' argument tells gunicorn to listen at port 8000 on localhost, 
		'myapp' is the python module containing the application and 'app' is 
		the application object defined in that module.  Often both of these 
		are just called 'app' which is fine, but makes it less clear what's 
		happening when the command is 
		<code class="language-bash">gunicorn app:app</code>.
		With gunicorn listening you should still get "Oh, Hi Mark." when you access the 
		public IP in browser.
	</li>

	<li>
		<h4>Hiding Gunicorn behind Supervisor.</h4>
		The last step is to create a supervisor job to babysit the gunicorn server.
		Kill the gunicorn process we started earlier and put following in a new file at 
		<code class="language-bash">/etc/supervisor/conf.d/hello.conf</code>

		<pre><code>[program:hello]
command=/home/ubuntu/hello/.venv/bin/gunicorn --bind localhost:8000 myapp:app
directory=/home/ubuntu/hello
user=ubuntu
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true</code></pre>
		
		Where I got stuck was not understanding this file.  'directory' is the 
		where you would need to be if you were going to execute 'command' by yourself.
		So seeing as we have been calling our server processes from 
		<code class="language-bash">~/hello</code>, make the full version 
		of that path the argument here.
		Since we installed gunicorn in the virtual environment it isn't actually 
		available outside. 
		If you tried
		<code class="language-bash">~$ gunicorn</code> 
		in stead of 
		<code class="language-bash">~£ gunicorn</code> 
		you'd get a 'command not found'
		message.  That's why the command has the full filepath to the virtual enviroment's 
		executable.
		Once that's done tell supervisor that you've changed some things with 
		<pre><code class="language-bash">~$ sudo supervisor reread
~$ sudo supervisor update</code></pre>
	</li>
		And that's it! Obviously there's plenty more to do but this is a robust start.
		Some things to look at from here (apart from extending the functionality of the 
		application) are 
		<ul>
			<li>Where are the logs going from all the various processes?</li>
			<li>What do we do about https?</li>
			<li>What are the options for configuring Gunicorn and nginx?</li>
		</ul>
		and so on but this setup will run happily and all of that can come later.

</ol>



{% endblock %}